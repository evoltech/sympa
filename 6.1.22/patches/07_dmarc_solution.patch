# Apply by cd-ing into the sympa src directory then running
# patch -p 0 < ../6.1.20/patches/07_dmarc_solution.patch
Index: src/lib/confdef.pm
===================================================================
--- src/lib/confdef.pm	(revision 10540)
+++ src/lib/confdef.pm	(revision 10550)
@@ -1305,6 +1305,39 @@
         ##default => 'from:sender:reply-to:subject:date:message-id:to:cc:list-id:list-help:list-unsubscribe:list-subscribe:list-post:list-owner:list-archive:in-reply-to:references:resent-date:resent-from:resent-sender:resent-to:resent-cc:resent-message-id:mime-version:content-type:content-transfer-encoding:content-id:content-description',
     ##},
 
+    {
+        'name'    => 'dmarc_protection_mode',
+        'query'   => 'Test mode(s) for DMARC Protection',
+        'sample'  => 'dmarc_reject,dkim_signature',
+        'vhost'   => '1',
+        'edit'    => '1',
+        'optional'=> '1',
+        'advice'  => 'Do not set unless you want to use DMARC protection.  This is a comma separated list of test modes; if multiple are selected then protection is activated if ANY match.  Do not use dmarc_* modes unless you have a local DNS cache as they do a DNS lookup for each received message.',
+    },
+    {
+        'name'    => 'dmarc_protection_domain_regex',
+        'query'   => 'Regexp for domain name match',
+        'vhost'   => '1',
+        'edit'    => '1',
+        'optional'=> '1',
+        'advice'  => 'This is used for the "domain_regex" protection mode.',
+    },
+    {
+        'name'    => 'dmarc_protection_phrase',
+        'query'   => 'Pattern used to create new From header phrase',
+        'vhost'   => '1',
+        'edit'    => '1',
+        'optional'=> '1',
+        'default' => 'name_via_list',
+    },
+    {
+        'name'    => 'dmarc_protection_other_email',
+        'query'   => 'Email to use for replacement From header',
+        'vhost'   => '1',
+        'edit'    => '1',
+        'optional'=> '1',
+    },
+
     { 'title' => 'Antivirus plug-in' },
 
     {
Index: src/lib/List.pm
===================================================================
--- src/lib/List.pm	(revision 10540)
+++ src/lib/List.pm	(revision 10550)
@@ -653,7 +653,51 @@
 			      'occurrence' => '0-1',
 			      'gettext_id' => "DKIM configuration",
 			  },
-			      
+            'dmarc_protection' => { 
+			  'format' => {
+                                   'mode' => { 'format' => [ 'none', 'all', 'dkim_signature', 'dmarc_reject', 'dmarc_any', 'dmarc_quarantine', 'domain_regex' ],
+				     'synonym' => {
+					'dkim' => 'dkim_signature',
+					'dkim_exists' => 'dkim_signature',
+					'dmarc_exists' => 'dmarc_any',
+					'domain' => 'domain_regex',
+					'domain_match' => 'domain_regex',
+				     },
+                                     'gettext_id' => "Protection modes",
+				     'split_char' => ',',
+		                     'occurrence' => '0-n',
+                                     'default' => { 'conf'=>'dmarc_protection_mode' },
+                                     'comment' => 'Select one or more operation modes.  "Domain matching regular expression" (domain_regex) matches the specified Domain regexp; "DKIM signature exists" (dkim_signature) matches any message with a DKIM signature header; "DMARC policy ..." (dmarc_*) matches messages from sender domains with a DMARC policy as given; "all" (all) matches all messages.',
+                                     'order' => 1
+                                   },
+                                   'domain_regex' => { 'format' => '.+',
+                                     'gettext_id' => "Match domain regexp",
+		                     'occurrence' => '0-1',
+				     'comment' => 'Regexp match pattern for From domain',
+                                     'order' => 2,
+                                     'default' => { 'conf'=>'dmarc_protection_domain_regex' },
+                                   },
+				   'other_email' => { 'format' => '.+',
+                                     'gettext_id' => "New From address",
+		                     'occurrence' => '0-1',
+                                     'comment' => 'This is the email address to use when modifying the From header.  It defaults to the list address.  This is similar to Anonymisation but preserves the original sender details in the From address phrase.',
+                                     'order' => 3,
+                                     'default' => { 'conf'=>'dmarc_protection_other_email' },
+                                   },
+				   'phrase' => { 'format' => [ 'display_name', 'name_and_email', 'name_via_list', 'name_email_via_list' ],
+				     'synonym' => {'name' => 'display_name'},
+                                     'default' => { 'conf'=>'dmarc_protection_phrase' },
+                                     'gettext_id' => "New From name format",
+		                     'occurrence' => '0-1',
+                                     'comment' => 'This is the format to be used for the sender name part of the new From header.',
+                                     'order' => 4,
+                                   },
+                          },
+                          'gettext_id' => "DMARC Protection",
+                          'group' => 'dkim',
+			  'comment' => 'Parameters to define how to manage From address processing to avoid some domains\' excessive DMARC protection', 
+			  'occurrence' => '0-1',
+                      },
 	    'editor' => {'format' => {'email' => {'format' => &tools::get_regexp('email'),
 						  'length' => 30,
 						  'occurrence' => '1',
@@ -1478,7 +1522,7 @@
     'list' => {'gettext_id' => 'list'},
 
     # include_ldap_2level_query.select2, include_ldap_2level_query.select1,
-    # include_ldap_query.select, reply_to_header.value
+    # include_ldap_query.select, reply_to_header.value, dmarc_protection.mode
     'all' => {'gettext_id' => 'all'},
 
     # reply_to_header.value
@@ -1491,7 +1535,8 @@
 
     # bouncers_level2.notification, bouncers_level2.action,
     # bouncers_level1.notification, bouncers_level1.action,
-    # spam_protection, dkim_signature_apply_on, web_archive_spam_protection
+    # spam_protection, dkim_signature_apply_on, web_archive_spam_protection,
+    # dmarc_protection.mode
     'none' => {'gettext_id' => 'do nothing'},
 
     # bouncers_level2.notification, bouncers_level1.notification,
@@ -1629,6 +1674,19 @@
     # archive_crypted_msg
     'original'  => {'gettext_id' => 'original messages'},
     'decrypted' => {'gettext_id' => 'decrypted messages'},
+
+    # dmarc_protection.mode
+    'dkim_signature' => {'gettext_id' => 'DKIM signature exists'},
+    'dmarc_any'      => {'gettext_id' => 'DMARC policy exists'},
+    'dmarc_reject'   => {'gettext_id' => 'DMARC policy suggests rejection'},
+    'dmarc_quarantine' => {'gettext_id' => 'DMARC policy suggests quarantine'},
+    'domain_regex'   => {'gettext_id' => 'domain matching regular expression'},
+
+    # dmarc_protection.phrase
+    'display_name'   => {'gettext_id' => 'display name'},
+    'name_and_email' => {'gettext_id' => 'display name and e-mail'},
+    'name_via_list'  => {'gettext_id' => 'name "via Mailing List"'},
+    'name_email_via_list' => {'gettext_id' => 'e-mail "via Mailing List"'},
 );
 
 ## Values for subscriber reception mode.
@@ -2750,6 +2808,127 @@
 	}
     }
 
+    ## Munge the From header if we are using DMARC Protection mode
+    if ( $self->{'admin'}{'dmarc_protection'}{'mode'} ) {
+        my $dkimdomain = $self->{'admin'}{'dmarc_protection'}{'domain_regex'};
+        my $originalFromHeader = $hdr->get('From');
+        my $anonaddr;
+        my @addresses = Mail::Address->parse($originalFromHeader);
+        my @anonFrom;
+        my $dkimSignature = $hdr->get('DKIM-Signature');
+        my $origFrom = '';
+        my $mungeFrom = 0;
+
+        if ( @addresses ) { $origFrom = $addresses[0]->address; }
+
+        # Will this message be processed?
+        $mungeFrom = 1 if( &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'all') );
+        if( !$mungeFrom and $dkimSignature 
+            and &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dkim_signature')) {
+            $mungeFrom = 1;
+        }
+        if( !$mungeFrom and $origFrom and $dkimdomain 
+            and &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'domain_regex') ) {
+            $mungeFrom = 1 if( $origFrom =~ /$dkimdomain$/ );
+        }
+        if( !$mungeFrom and $origFrom 
+            and (
+                &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dmarc_reject')
+                or &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dmarc_any')
+                or &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dmarc_quarantine')
+            )) {
+            # Strict auto policy - is the sender domain policy to reject
+            my $dom = $origFrom; $dom =~ s/^.*\@//;
+            eval { # In case Net::DNS is not installed
+                require Net::DNS;
+                my $res = Net::DNS::Resolver->new;
+                my $packet = $res->query("_dmarc.$dom","TXT");
+                if ($packet) {
+                    foreach my $rr (grep { $_->type eq 'TXT' } $packet->answer) {
+                        next if($rr->string !~ /v=DMARC/);
+                        if(!$mungeFrom and &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dmarc_reject')) {
+                            $mungeFrom = 1 if($rr->string =~ /p=reject/);
+                        }
+                        if(!$mungeFrom and &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dmarc_quarantine')) {
+                            $mungeFrom = 1 if($rr->string =~ /p=quarantine/);
+                        }
+                        if(!$mungeFrom and &tools::is_in_array($self->{'admin'}{'dmarc_protection'}{'mode'},'dmarc_any')) {
+                            $mungeFrom = 1;
+                        }
+                        $hdr->add('X-Original-DMARC-Record',"domain=$dom; ".$rr->string);
+                        last;
+                    }
+                }
+            };
+            $hdr->add('X-DMARC-Error',$@) if($@);
+        }
+
+        if( $mungeFrom ) {
+            # Remove any DKIM signatures we find
+            if( $dkimSignature ) {
+                $hdr->add('X-Original-DKIM-Signature',$dkimSignature);
+                $hdr->delete('DKIM-Signature');
+                $hdr->delete('DomainKey-Signature');
+            }
+
+            # Identify default new From address
+            my $phraseMode = $self->{'admin'}{'dmarc_protection'}{'phrase'} ||
+                'name_via_list';
+            my $newAddr;
+            my $displayName;
+            my $newComment;
+            $anonaddr = $self->{'admin'}{'dmarc_protection'}{'other_email'};
+            $anonaddr = $self->get_list_address()
+                unless $anonaddr and $anonaddr =~ /\@/;
+            @anonFrom = Mail::Address->parse($anonaddr);
+
+            if (@addresses) {
+                # We should always have a From address in reality, unless the
+                # message is from a badly-behaved automate
+                if ($addresses[0]->phrase) {
+                    $displayName = MIME::EncWords::decode_mimewords(
+			$addresses[0]->phrase, Charset => 'UTF-8');
+                    $newComment = $addresses[0]->address
+			if $phraseMode =~ /email/;
+                } else {
+                    # If we dont have a Phrase, should we search the Sympa database
+                    # for the sender to obtain their name that way? Might be difficult.
+                    $displayName = $addresses[0]->address;
+                    $displayName =~ s/\@.*// unless $phraseMode =~ /email/;
+                }
+                if($phraseMode =~ /list/) {
+                    if ($newComment and $newComment =~ /\S/) {
+                        $newComment =
+                            sprintf gettext('%s via %s Mailing List'),
+                                $newComment, $name;
+                    } else {
+                        $newComment =
+			    sprintf gettext('via %s Mailing List'), $name;
+                    }
+                }
+                $hdr->add('Reply-To',$addresses[0]->address) unless($hdr->get('Reply-To'));
+            }
+            # If the new From email address has a Phrase component, then append it
+            if (@anonFrom and $anonFrom[0]->phrase) {
+                if ($displayName and $displayName =~ /\S/) {
+                    $displayName .= ' ' . $anonFrom[0]->phrase;
+                } else {
+                    $displayName = $anonFrom[0]->phrase;
+                }
+            }
+            $displayName = gettext('Anonymous')
+                unless $displayName and $displayName =~ /\S/;
+
+            $newAddr = tools::addrencode(
+		(@anonFrom ? $anonFrom[0]->address : $anonaddr),
+		$displayName, Language::GetCharset(), $newComment);
+
+            $hdr->add('X-Original-From',"$originalFromHeader");
+            $hdr->replace('From', $newAddr);
+        }
+
+    }
+
     ## Hide the sender if the list is anonymoused
     if ( $self->{'admin'}{'anonymous_sender'} ) {
 
Index: src/lib/tools.pm
===================================================================
--- src/lib/tools.pm	(revision 10540)
+++ src/lib/tools.pm	(revision 10550)
@@ -3930,35 +3930,42 @@
 #*******************************************
 # Function : addrencode
 # Description : return formatted (and encoded) name-addr as RFC5322 3.4.
-## IN : addr, [phrase, [charset]]
+## IN : addr, [phrase, [charset, [comment]]]
 #*******************************************
 sub addrencode {
     my $addr = shift;
     my $phrase = (shift || '');
     my $charset = (shift || 'utf8');
+    my $comment = (shift || '');
 
     return undef unless $addr =~ /\S/;
 
     if ($phrase =~ /[^\s\x21-\x7E]/) {
-	# Minimal encoding leaves special characters unencoded.
-	# In this case do maximal encoding for workaround.
-	my $minimal =
-	    ($phrase =~ /(\A|\s)[\x21-\x7E]*[\"(),:;<>\@\\][\x21-\x7E]*(\s|\z)/)?
-	    'NO': 'YES';
 	$phrase = MIME::EncWords::encode_mimewords(
 	    Encode::decode('utf8', $phrase),
 	    'Encoding' => 'A', 'Charset' => $charset,
 	    'Replacement' => 'FALLBACK',
 	    'Field' => 'Resent-Sender', # almost longest
-	    'Minimal' => $minimal
+	    'Minimal' => 'DISPNAME',	# needs MIME::EncWords >= 1.012.
             );
-	return "$phrase <$addr>";
     } elsif ($phrase =~ /\S/) {
 	$phrase =~ s/([\\\"])/\\$1/g;
-	return "\"$phrase\" <$addr>";
-    } else {
-	return "<$addr>";
+	$phrase = '"' . $phrase . '"';
     }
+    if ($comment =~ /[^\s\x21-\x27\x2A-\x5B\x5D-\x7E]/) {
+	$comment = MIME::EncWords::encode_mimewords(
+	    Encode::decode('utf8', $comment),
+	    'Encoding' => 'A', 'Charset' => $charset,
+	    'Replacement' => 'FALLBACK',
+	    'Minimal' => 'DISPNAME',
+	    );
+    } elsif ($comment =~ /\S/) {
+	$comment =~ s/([\\\"])/\\$1/g;
+    }
+
+    return ($phrase =~ /\S/ ? "$phrase " : '')
+	. ($comment =~ /\S/ ? "($comment) " : '')
+	. "<$addr>";
 }
 
 #*******************************************
